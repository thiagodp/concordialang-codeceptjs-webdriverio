import * as path  from "path";
import * as childProcess from 'child_process';
import { promisify } from 'util';
import { writeFile, access, constants, readFile } from 'fs';
import chalk from 'chalk';
import { arrowRight, info, cross, warning } from 'figures';
import * as fse from 'node-fs-extra';
import { TestScriptExecutionOptions } from 'concordialang-types';
import { ConfigMaker } from './ConfigMaker';

/**
 * Executes test scripts generated by Concordia using CodeceptJS.
 */
export class TestScriptExecutor {

    constructor(
        private readonly _defaultConfig: object
    ) {
    }

    /**
     * Executes the script according to the options given.
     *
     * @param options Execution options
     */
    public async execute( options: TestScriptExecutionOptions ): Promise< string > {

        const iconInfo = chalk.blueBright( info );
        const iconWarning = chalk.yellow( warning );
        const textColor = chalk.cyanBright;
        const textCommand = chalk.cyan;
        const highlight = chalk.yellowBright;

        // Creates the source code dir if it does not exist
        if ( !! options.sourceCodeDir ) {
            fse.mkdirs( options.sourceCodeDir );
        }

        // Creates the execution result/output dir if it does not exist
        if ( !! options.executionResultDir ) {
            fse.mkdirs( options.executionResultDir );
        }

        const executionPath = process.cwd();

        // codecept.json -------------------------------------------------------

        await this.assureConfigurationFile( executionPath );

        // Run CodeceptJS -------------------------------------------------------

        let filter: string = '';
        if ( options && options.filter ) {
            filter = options.filter.scenarioName || options.filter.featureName || '';
        }

        const command: string = filter
            ? `npx codeceptjs run --grep ${filter} --reporter mocha-multi --colors || echo .`
            : 'npx codeceptjs run --reporter mocha-multi --colors || echo .';

        this.write( iconInfo, textColor( 'Running tests...' ) );
        this.write( ' ', textCommand( command ) );
        const code: number = await this.runCommand( command );

        // Output file ----------------------------------------------------------

        const OUTPUT_FILE_NAME = 'output.json';
        const outputFilePath = path.join( options.executionResultDir || '.', OUTPUT_FILE_NAME );
        this.write( iconInfo, textColor( 'Retrieving output file' ), highlight( outputFilePath ) + textColor( '...' ) );

        return outputFilePath;
    }


    private async fileExists( path: string ): Promise< boolean > {
        try {
            const accessFile = promisify( access );
            await accessFile( path, constants.F_OK );
            return true;
        } catch ( e ) {
            return false;
        }
    }


    public async assureConfigurationFile( executionPath: string ): Promise< boolean > {

        const iconInfo = chalk.blueBright( info );
        const iconError = chalk.redBright( cross );
        const textColor = chalk.cyanBright;
        const highlight = chalk.yellowBright;

        const writeF = promisify( writeFile );

        const codeceptJSConfigFile = path.join( executionPath, 'codecept.json' );
        const configFileExists: boolean = await this.fileExists( codeceptJSConfigFile );

        // It's only possible to run CodeceptJS if there is a config file
        if ( ! configFileExists ) {

            try {
                await writeF( codeceptJSConfigFile, JSON.stringify( this._defaultConfig, undefined, "\t" ) );

                this.write( iconInfo, textColor( 'Generated configuration file' ), highlight( codeceptJSConfigFile ) );
                this.write( arrowRight, textColor( 'If this file does not work for you, delete it and then run:' ) );
                this.write( textColor( '  codeceptjs init' ) );
            } catch ( e ) {
                this.write( iconError, textColor( 'Could not generate' ), highlight( codeceptJSConfigFile ) + '.', textColor( 'Please run the following command:' ) );
                this.write( textColor( '  codeceptjs init' ) );
                return false;
            }

        } else {

            // Let's check needed dependencies
            let config = {};
            try {
                const readF = promisify( readFile );
                const content = await readF( codeceptJSConfigFile );
                config = JSON.parse( content.toString() );

                this.write( iconInfo, textColor( 'Read' ), highlight( codeceptJSConfigFile ) );
            } catch ( e ) {
                this.write( iconError, textColor( 'Could not read' ), highlight( codeceptJSConfigFile ) );
                return false;
            }

            const cfgMaker = new ConfigMaker();

            let needsToWriteConfig: boolean = ! cfgMaker.hasHelpersProperty( config );

            if ( ! cfgMaker.hasCmdHelper( config ) ) {
                cfgMaker.setCmdHelper( config );
                needsToWriteConfig = true;
            }

            if ( ! cfgMaker.hasDbHelper( config ) ) {
                cfgMaker.setDbHelper( config );
                needsToWriteConfig = true;
            }

            if ( needsToWriteConfig ) {
                try {
                    await writeF( codeceptJSConfigFile, JSON.stringify( config ) );
                    this.write( iconInfo, textColor( 'Updated configuration file' ), highlight( codeceptJSConfigFile ) );
                } catch ( e ) {
                    this.write( iconError, textColor( 'Error updating configuration file' ), highlight( codeceptJSConfigFile ) + '. Please check if it has DbHelper and CmdHelper configured.' );
                    return false;
                }
            }
        }

        return true;
    }

    // private escapeJson( json: string ): string {
    //     return JSON.stringify( { _: json} ).slice( 6, -2 );
    // }

    private async runCommand(
        command: string
    ): Promise< number > {

        let options = {
            // stdio: 'inherit', // <<< not working on windows!
            shell: true
        };

        // Splits the command into pieces to pass to the process;
        //  mapping function simply removes quotes from each piece
        let cmds = command.match( /[^"\s]+|"(?:\\"|[^"])+"/g )
            .map( expr => {
                return expr.charAt( 0 ) === '"' && expr.charAt( expr.length - 1 ) === '"' ? expr.slice( 1, -1 ) : expr;
            } );
        const runCMD = cmds[ 0 ];
        cmds.shift();

        return new Promise< number >( ( resolve, reject ) => {

            const child = childProcess.spawn( runCMD, cmds, options );

            child.stdout.on( 'data', ( chunk ) => {
                console.log( chunk.toString() );
            } );

            child.stderr.on( 'data', ( chunk ) => {
                console.warn( chunk.toString() );
            } );

            child.on( 'exit', ( code ) => {
                resolve( code );
            } );

        } );
    }

    private write( ... args ): void {
        console.log( ... args );
    }

}
